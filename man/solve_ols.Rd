% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hw2.R
\name{solve_ols}
\alias{solve_ols}
\title{This function solves a linear system using Gauss-Seidel or Jacobi method,
if choose to do parallel, it allows user to specify how many
cores to use for parallel implementation.}
\usage{
solve_ols(
  X,
  Y,
  algorithm = "Gauss-Seidel",
  ncores = as.numeric(Sys.getenv("NUMBER_OF_PROCESSORS", "2")),
  max_it = 10^6,
  tolerance = 10^(-4)
)
}
\arguments{
\item{X}{The design matrix}

\item{Y}{The response variable vector}

\item{algorithm}{includes "Gauss-Seidel", "Jocobi", "parallel Gauss-Seidel",
and "parallel Jacobi". Can use integers 1, 2, 3, and 4 respectively.
If not specified, it would do "Gauss-Seidel".}

\item{ncores}{#the number of the cores that the user would like to use for
the parallel. If not specified, it would use the number of the system processors.}

\item{max_it}{#max number of iteration. Default setting is 10^4.}

\item{tolerance}{# return when difference between two consecutive steps of beta are
smaller then this value.}
}
\value{
the estimator vector of the parameters.
It would pop up error messages when requirements for either convergence,
shape of the design matrix, and algorithm name doesn't meet.
}
\description{
This function solves a linear system using Gauss-Seidel or Jacobi method,
if choose to do parallel, it allows user to specify how many
cores to use for parallel implementation.
}
\examples{
n = 100
D = diag(rep(3, n))
U = rbind(cbind(rep(0, n - 1), diag(rep(-1, n - 1))), rep(0, n))
L = t(U)
v = rep(c(1, 0), as.integer(n / 2))
print(L+D+U)
b = (L + D + U) \%*\% v
X = L + D + U
solve_ols(X,b)
}
